# **第三章：基础概念**

## **过程调用与 x86 栈帧管理**

### **1. 引言**
本节讲解 **Intel x86 体系结构** 中 **函数调用和栈帧管理**。当 C 语言中的函数被调用时，会创建 **栈帧（Stack Frame）** 来存储：
- **函数参数**。
- **返回地址**（调用者的指令指针）。
- **保存的寄存器**。
- **局部变量**。

理解 **栈帧** 对于掌握 **函数调用、递归、系统调用** 至关重要。

---

### **2. C 语言中的过程调用**
#### **2.1 示例 C 代码**
以下是一个简单的 C 代码示例：

```c
int main() {
    int i;
    int a;
    
    // 其他操作...

    i = sub(a, 1);  // 调用子程序 sub
    
    return 0;
}

int sub(int x, int y) {
    int i;
    int result = 1;
    for (i = 0; i < y; i++)
        result *= x;
    return result;
}
```
##### **代码作用**
- `sub(x, y)` 计算 **x^y**（即 x 的 y 次幂）。
- `sub` 函数包含 **局部变量** `i` 和 `result`，以及 **参数** `x` 和 `y`。
- 每次调用 `sub` 都会创建一个新的 **栈帧**。

---

### **3. Intel x86 体系结构中的栈帧**
#### **3.1 栈的组织方式**
在 **Intel x86 体系结构** 中，栈的结构如下：
1. **函数参数**（Arguments）。
2. **返回地址**（指令指针 EIP）。
3. **保存的帧指针（EBP）**。
4. **局部变量** 和 **保存的寄存器**。

**关键寄存器：**
- **`ebp`（基址指针）**：指向当前栈帧的基址。
- **`esp`（栈指针）**：指向栈顶。
- **`eax`（累加寄存器）**：存储函数返回值。

#### **3.2 栈帧布局**
当 `sub` 被调用时，栈的结构如下：
```
[ 高地址 ]
-------------------------
|  调用者的栈帧        |
-------------------------
|  返回地址 (EIP)       | <- 存储调用 sub() 之前的地址
|  旧 EBP              | <- 之前的栈帧指针
|  局部变量            | <- sub() 的局部变量
|  保存的寄存器        | <- 如果修改了寄存器，则需要保存
-------------------------
[ 低地址 ]
```
---

### **4. 过程调用的汇编代码**
#### **4.1 main 函数的汇编代码**
```assembly
main:
    pushl  %ebp            # 保存旧的基址指针
    movl   %esp, %ebp      # 设置新的基址指针
    subl   $8, %esp        # 为局部变量分配空间

    pushl  $1              # 将参数 y 压入栈
    movl   -4(%ebp), %eax  # 从局部变量加载参数 x
    pushl  %eax            # 将 x 压入栈
    call   sub             # 调用 sub 过程
    addl   $8, %esp        # 清理栈（移除参数）
    movl   %eax, -8(%ebp)  # 将返回值存入局部变量

    movl   $0, %eax        # 设置返回值为 0
    popl   %ebp            # 恢复基址指针
    ret                    # 返回到调用者
```

#### **4.2 子程序的汇编代码**
```assembly
sub:
    pushl  %ebp            # 保存调用者的基址指针
    movl   %esp, %ebp      # 设置新的基址指针
    subl   $8, %esp        # 为局部变量分配空间

    movl   $1, -4(%ebp)    # 初始化 result = 1
    movl   $0, -8(%ebp)    # 初始化 i = 0
beginloop:
    cmpl   12(%ebp), %eax  # 比较 i 和 y
    jge    endloop         # 如果 i >= y，跳出循环
    imull  8(%ebp), %ecx   # result *= x
    addl   $1, %eax        # i++
    jmp    beginloop       # 继续循环
endloop:
    movl   %ecx, -4(%ebp)  # 将结果存入栈
    movl   -4(%ebp), %eax  # 载入返回值
    movl   %ebp, %esp      # 恢复栈指针
    popl   %ebp            # 恢复基址指针
    ret                    # 返回到调用者
```

#### **4.3 代码解释**
1. **前序部分（Prologue，进入 `sub` 过程）**
   - **保存前一个栈帧** (`pushl %ebp`)。
   - **创建新的栈帧** (`movl %esp, %ebp`)。
   - **为局部变量分配空间** (`subl $8, %esp`)。

2. **函数执行**
   - 循环计算 `result = x^y`。
   - 使用 `imull` 指令进行整数乘法。

3. **后序部分（Epilogue，退出 `sub` 过程）**
   - **恢复栈指针 (`movl %ebp, %esp`)**。
   - **返回 (`ret`)**，弹出返回地址并跳回调用者。

---

### **5. 总结**
- **栈帧（Stack Frame）** 管理 x86 体系结构中的函数调用。
- **关键寄存器 (`ebp`, `esp`, `eax`)** 组织栈内存。
- **汇编语言** 展示了函数调用的底层执行机制。
- **高效的栈管理** 可避免递归调用时的栈溢出。

---
