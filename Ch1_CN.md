# **第一章：操作系统**

## **操作系统解析**

### **什么是操作系统？**  
操作系统（Operating System, OS）是计算机中的**核心软件**，它位于**应用程序**和**硬件**之间，负责**管理资源**并提供**抽象接口**，使用户和软件能够高效使用计算机。

简单来说，  
> **操作系统是计算机中所有程序赖以运行的基础软件。**  

由于操作系统的应用环境不同，其定义也较为宽泛，不同计算机体系可能对 OS 的边界有不同理解。

---

### **操作系统的功能**  
从**程序员的角度**来看，操作系统的主要功能是**抽象化硬件**，并管理计算机资源的**共享**。

操作系统提供的主要硬件抽象包括：
- **处理器（CPU）** – 负责进程调度和任务执行。
- **内存（RAM）** – 负责动态分配和管理主存空间。
- **磁盘（Disk）** – 负责存储管理，提供文件系统支持。
- **网络接口（Network Interface）** – 提供联网和数据通信能力。
- **显示设备（Display）** – 处理图形渲染和输出。
- **输入设备（Keyboard & Mouse）** – 处理用户输入事件。

---

### **操作系统的核心抽象概念**

1. **进程抽象（Process Abstraction）**
   - 进程（Process）是**正在执行的程序**，它认为自己独占 CPU 和内存。
   - 操作系统**调度进程**，并在进程间分配 CPU 资源。
   - 实际上，内存可能部分存储在 **磁盘（虚拟内存）** 中。

2. **文件抽象（File Abstraction）**
   - 操作系统通过**文件**提供存储抽象，而不是让用户直接管理**磁盘存储**。
   - 文件系统支持：
     - 创建文件
     - 读写文件
     - 删除文件

3. **网络抽象（Networking Abstraction）**
   - 操作系统提供**标准化的网络接口**：
     - **套接字（Sockets）** – 进行直接网络通信。
     - **远程过程调用（RPC）** – 远程调用计算机上的方法。
     - **Web 协议** – 例如 HTTP/HTTPS 处理网络请求。

4. **输入/输出设备抽象（I/O Abstraction）**
   - 操作系统提供 **窗口系统和图形界面** 来处理 UI 交互。
   - 鼠标点击和键盘输入**被转换为系统事件**，无需应用程序直接处理低级输入信号。

---

### **为什么要进行抽象？**  

1. **简化编程（Simplifies Programming）**
   - 开发者无需直接操作硬件，只需使用**文件、进程等抽象概念**。

2. **支持资源共享（Enables Resource Sharing）**
   - 操作系统**多路复用（Multiplexing）** 计算资源，让多个应用程序能同时运行。

3. **提高系统效率（Improves Efficiency）**
   - 通过**调度算法**优化 CPU 使用率。
   - **虚拟内存**允许程序运行，即使物理内存不足。

---

### **操作系统的边界**  
一些抽象概念属于**操作系统范畴**，但某些属于**独立领域**：

| 操作系统功能          | 其他计算机领域 |
|----------------------|--------------|
| **文件系统（File System）** | 数据库（Database） |
| **基本图形处理（Graphics Handling）** | 计算机图形学（Computer Graphics） |
| **进程管理（Process Management）** | 分布式系统（Distributed Systems） |

例如，**文件系统**通常属于操作系统，而**数据库管理**则是一个独立领域。

---

### **总结**  
操作系统是计算机的**核心软件**，其主要职责包括：
✅ **进程管理** – 调度和执行程序。  
✅ **文件系统管理** – 组织和管理磁盘存储。  
✅ **内存管理** – 高效分配 RAM 资源。  
✅ **网络通信** – 处理联网功能。  
✅ **用户界面管理** – 处理输入/输出设备。  

操作系统的目标是**让用户和程序能够高效使用计算机资源**，而无需直接操作硬件。

---

## **操作系统作为一门研究领域**

### **为什么要研究操作系统？**  
操作系统（OS）一直是**计算机科学的核心学科**，从计算机学科诞生以来，它就被纳入标准课程体系。有人可能认为，**操作系统已经是一个解决完毕的问题**，因为现代操作系统已经实现了：  
- **高效的进程管理**，能够同时运行多个程序。  
- **稳定的文件系统**，能以最优方式存储和访问数据。  
- **安全的网络通信**，确保数据在不同设备之间可靠传输。  

然而，**新的挑战不断涌现**，使得操作系统研究成为**持续进行的领域，而不是一个已经完全解决的问题**。

---

### **操作系统是一个已解决的问题吗？**  

✅ **当前操作系统的优势**  
- 现代操作系统支持**同时运行多个进程**，无论这些进程是否相互独立或协作。  
- 用户可以**独享计算机的感觉**，即使后台有多个任务在同时运行。  
- **程序崩溃不会影响整个系统**，因为操作系统提供了进程隔离。  
- **文件系统非常高效**，在存储空间和访问速度之间取得了良好平衡。  
- **容错能力**允许系统在硬件故障后恢复数据。  
- **网络传输稳定可靠**，能够高效地进行大规模数据交换。

⚠️ **仍然存在的挑战**  
- **安全漏洞**：计算机系统仍然**不断受到黑客攻击**，并且部分攻击成功。  
- **系统崩溃**：应用程序中的错误**仍然可能导致操作系统崩溃**，尽管比过去要少得多。  
- **拒绝服务（DoS）攻击**：如果攻击者向服务器发送大量请求，系统可能会**陷入瘫痪**。  
- **数据损坏**：尽管有备份和错误检测机制，**数据丢失和损坏仍然可能发生**。

---

### **现代操作系统面临的挑战**  

1. **进程隔离和安全防护（Isolation & Security）**  
   - **操作系统需要隔离不同进程**，防止一个程序影响另一个程序的运行。  
   - 这是**从操作系统诞生以来的一个核心目标**，但至今仍未完全解决。  
   - 目前的解决方案：**虚拟机（VM）和容器（Container）**，但它们仍然存在**安全漏洞**。

2. **网络攻击与信息安全**  
   - 早期的操作系统关注于**防止程序错误导致系统崩溃**。  
   - 过去的文件系统**主要通过物理安全手段（如加密磁盘）** 来保障数据安全。  
   - **今天的操作系统必须应对黑客和国家级网络攻击**，这些攻击者可能比操作系统开发者更了解其漏洞。

3. **计算模式的转变：云计算**  
   - 计算环境正在向**云端**迁移，数据和应用程序越来越多地存储在云服务器上。  
   - 但云计算的底层仍然依赖**传统的操作系统**来管理文件、进程和资源。  
   - 这表明，即使计算模式正在改变，**操作系统仍然至关重要**。

---

### **结论：为什么操作系统仍然重要？**  
尽管**许多基本的操作系统问题已经被解决**，但这个领域**仍在不断发展**，因为：  
✅ **新的安全威胁**要求操作系统提供更好的隔离和保护机制。  
✅ **计算规模扩大**（云计算、物联网、分布式系统）对操作系统提出更高的要求。  
✅ **系统健壮性**仍需提高，以更好地应对崩溃、故障和攻击。  

**操作系统仍然是一个重要的研究领域，它必须不断适应计算安全、可扩展性和性能的新挑战。**

---

## **一个简单的操作系统——早期 Unix**  

本节探讨 **一个相对简单的操作系统提供的抽象概念**，以及它们是如何实现的。我们选择讨论的是**1970 年代早期版本的 Unix**。  

---

### **为什么学习早期 Unix？**  

选择研究哪种操作系统 **往往存在争议**，但 **早期 Unix 是一个理想的选择**，原因如下：  
1. **简洁与优雅** – 设计清晰、极简主义，易于理解。  
2. **重大影响** – 现代操作系统（如 **Linux、MacOS、Windows**）都受到了 **Unix 的影响**。  
3. **仍然在使用** – 许多早期操作系统已经被淘汰，但 **Unix 及其衍生版本仍然活跃**。  

尽管 **IBM 的 OS/360 仍然存在后续版本**，但它很少对计算机课程的学生开放。因此，Unix 是 **更合适的学习选择**。  

我们将在本节中简称其为 **Unix**，但实际上它的正式名称是 **第六版 Unix（Unix V6）**。  

---

### **为什么说早期 Unix 是一个简单的操作系统？**  

早期 Unix 引入了许多关键的 **操作系统概念**，后来成为标准：  
✅ **进程（Processes）** – 每个程序都在独立的 **进程** 中运行。  
✅ **文件系统（File System）** – 采用 **分层结构** 来存储和管理文件。  
✅ **系统调用（System Calls）** – 程序通过 **系统调用接口** 与 OS 交互。  
✅ **多任务（Multitasking）** – 早期的 **分时系统** 允许多个用户同时运行程序。  

虽然从现代角度来看，Unix V6 仍然非常 **原始**，但它为 **现代操作系统的设计奠定了基础**。  

---

### **接下来的学习内容**  

在后续章节，我们将深入研究：  
🔹 **Unix 操作系统结构** – 内核如何组织？  
🔹 **进程与内存管理** – Unix 如何管理运行的程序？  
🔹 **文件与系统调用** – 应用程序如何与文件系统交互？  

通过学习 **早期 Unix**，我们可以更深入地理解 **现代操作系统的核心原理**。

---

## **操作系统结构**  

### **早期操作系统的设计**  
早期的操作系统 **非常小巧**，主要受**硬件限制**的影响。例如：  
- **第六版 Unix（Unix V6）** 需要适配 **64 KB 内存**。  
- 这导致整个 OS **作为一个单一的可执行文件** 运行。  
- 这种设计称为 **单体内核（Monolithic OS）**。

### **简单操作系统的工作方式**  
操作系统通过 **两种机制** 与应用程序和硬件交互：  
1. **陷阱（Traps）** – 允许应用程序 **向操作系统请求服务**（例如文件操作、内存管理）。  
2. **中断（Interrupts）** – 由**硬件设备**（如磁盘、时钟）触发，通知操作系统 **处理外部事件**。

### **用户模式 vs. 特权模式**  
现代 CPU 通常提供 **至少两种执行模式**：
- **用户模式（User Mode）** 🟢 – **应用程序** 在此模式下运行，权限受限。  
- **特权模式（Privileged Mode）** 🔴 – **操作系统内核** 运行在此模式，可以 **直接管理系统资源**。

### **内核的作用**  
- **内核（Kernel）** 指的是 **运行在特权模式下的操作系统部分**。  
- 在 **早期 OS（如 Unix V6）** 中，**整个操作系统都运行在特权模式**。  
- 在 **现代 OS（如 Windows、Linux）** 中，**部分 OS 组件运行在用户模式**，以增强安全性和模块化。

### **核心要点总结**  
✅ **早期 OS 结构简单** – **所有组件都在特权模式运行**。  
✅ **现代 OS 更复杂** – **部分 OS 组件运行在用户模式，提高安全性**。  
✅ **内核至关重要** – 它负责 **硬件管理、内存分配、进程控制**，保证 OS 正常运行。

---

## **操作系统中的 Traps（陷阱）**  

### **什么是 Traps（陷阱）？**  
Trap 是一种**从用户模式切换到内核模式**的机制，允许**用户程序调用操作系统内核**。  

Trap 可以分为 **两类**：  
1. **非故意触发（错误和异常）** – 由于**程序错误**导致的，例如：  
   - 访问**无效的内存地址**。  
   - **除零错误**。  
2. **故意触发（系统调用）** – **用户程序主动请求 OS 服务**（将在后续章节讨论）。  

---

### **操作系统如何处理 Traps？**  
当 Trap 发生时，OS **必须做出适当响应**：  
- **页面错误（Page Fault）** → 如果程序访问**缺失的内存页**，操作系统会**从磁盘加载该页**。  
- **程序错误（Programming Errors）**：
  - 如果 **没有设置错误处理程序**，操作系统**终止程序**。  
  - 如果 **有错误处理程序**，它可以**尝试恢复，或者进行清理后终止**。  

---

### **Unix 如何处理 Traps？（信号机制）**  
Unix 通过 **信号（Signals）** 处理错误，信号可以让 OS **通知用户程序**某个事件发生：  
- **OS 发送信号**给程序。  
- **程序可以注册信号处理函数**，来决定如何应对错误。  
- 这种机制称为 **upcall（向上调用）**，即**内核调用用户程序中的函数**。  

---

### **核心要点总结**  
✅ **Traps 允许程序从用户模式切换到内核模式**，以处理错误或执行系统调用。  
✅ **页面错误和程序错误会触发 OS 的响应**，确保系统稳定运行。  
✅ **Unix 通过信号机制（Signals）** 让用户程序**可以处理错误**，而不是直接崩溃。

---

## **系统调用（System Calls）**  

### **什么是系统调用？**  
系统调用是 **用户程序与操作系统内核之间的接口**。  
- 普通 **函数调用** 在 **用户模式** 下执行。  
- **系统调用** 允许用户程序请求 **操作系统提供的特权服务**。  

这确保了 **操作系统可以控制对系统资源的访问**，并提供安全性。

---

### **为什么要使用系统调用？**  
- **内核拥有对整个系统的控制权**，不允许用户程序直接访问硬件。  
- 因此，程序必须通过 **系统调用请求文件访问、内存管理、进程控制等服务**。  
- **系统调用是受控入口**，OS **可以在执行前验证请求的合法性**。

---

### **示例：`write` 系统调用**  
在 Unix/Linux 中，一个常见的系统调用是 `write()`，用于向文件写入数据。

#### **示例代码：**
```c
if (write(FileDescriptor, BufferAddress, BufferLength) == -1) {
    /* 发生错误：进行错误处理 */
    printf("error: %d\n", errno);  /* 打印错误信息 */
}
```

#### **执行流程：**
1. **用户程序调用 `write()`** 请求向文件写入数据。  
2. **操作系统执行以下步骤：**  
   - **检查请求是否有效**（文件是否存在？是否有权限？）。  
   - **执行写入操作**。  
   - **返回写入的字节数**（如果失败，则返回 `-1`）。  
   - 如果发生错误，错误代码会存储在 **`errno`** 变量中。

---

### **系统调用的内部执行原理**  
1. **用户调用系统函数**（如 `write()`）。  
2. **特殊指令触发 trap（陷阱），切换到内核模式**。  
3. **操作系统接管控制权**。  
4. **操作系统验证并执行请求**。  
5. **返回执行结果给用户程序**。  

这种机制保证了 **操作系统对关键资源的管理和访问控制**。

---

### **核心要点总结**  
✅ **系统调用是用户程序与 OS 交互的关键接口**。  
✅ **它们提供受控访问**（文件系统、内存管理、进程管理等）。  
✅ **trap 指令切换到内核模式，确保安全执行**。  
✅ **OS 处理请求后，将结果返回给用户程序**。

---

## **操作系统中的中断（Interrupts）**  

### **什么是中断？**  
**中断（Interrupt）** 是 **外部设备向处理器发送的请求信号**，要求 CPU 处理某个事件。  
- 中断 **独立于当前运行的程序**。  
- OS 通过中断 **处理异步事件**，例如：
  - **键盘输入**（用户按下按键）。  
  - **磁盘操作**（数据读取完成）。  
  - **网络活动**（数据包到达）。  

---

### **中断 vs. 陷阱（Trap）**  
中断和陷阱都 **会将控制权交给操作系统**，但它们的 **触发方式和处理方式不同**：

| 特性       | **中断（Interrupt）** | **陷阱（Trap）** |
|------------|----------------|----------------|
| **来源**   | **外部设备**（硬件触发） | **程序内部**（软件触发） |
| **触发方式** | **异步（随时可能发生）** | **同步（程序执行时触发）** |
| **影响**   | **独立于当前运行的程序** | **直接影响当前运行的程序** |
| **示例**   | **磁盘读写完成、网络数据包到达** | **除零错误、系统调用、缺页异常** |

---

### **示例：磁盘读取完成中断**
#### **场景：程序从磁盘读取数据**
1. **程序请求读取磁盘数据**。  
2. **CPU 继续执行其他指令**（因为磁盘读取速度较慢）。  
3. **磁盘读取完成后，磁盘控制器发送中断信号**。  
4. **CPU 暂停当前任务，切换到内核模式，处理中断**。  
5. **操作系统通知请求的程序：数据已准备好**。  

---

### **核心要点总结**  
✅ **中断允许操作系统异步处理外部设备请求**。  
✅ **中断与陷阱不同**，陷阱是程序内部错误或系统调用触发的。  
✅ **高效的中断处理能提高 CPU 利用率**，避免 CPU 因等待 I/O 任务而闲置。

---


## **进程、地址空间和线程**  

### **什么是进程（Process）？**  
**进程** 是 **操作系统的核心抽象之一**，代表 **正在运行的程序**，由 **两部分组成**：  
1. **地址空间（Address Space）** – 进程可以访问的 **内存范围**。  
2. **线程（Threads）** – 进程中的 **执行单元**。  

在现代操作系统中，进程的 **地址空间相互隔离**，防止进程直接访问其他进程的内存。OS 依靠 **地址转换硬件（Address Translation Hardware）** 来实现这一点。

---

### **Unix 的地址空间结构**  
当程序运行时，OS **将其加载到进程的地址空间**，其结构如下（内存地址从低到高）：  
1. **文本段（Text/Code）** – 存储 **可执行指令**，通常是 **只读的**。  
2. **数据段（Data）** – 存储 **全局变量**。
   - **已初始化数据（Initialized Data）** – 具有初始值的变量。  
   - **BSS（未初始化数据）** – **没有初始值的变量**，但默认初始化为 **零**。  
3. **堆区（Heap）** – **动态分配的内存**（如 C 语言中的 `malloc()`）。  
   - **在大多数架构中，堆是向下增长的**。
4. **栈区（Stack）** – **存储局部变量和函数返回地址**。
   - **在大多数架构中，栈是向上增长的**。

---

### **线程 vs. 进程**
- **一个进程至少包含一个线程**。  
- **早期 OS（如 Unix V6）** 仅支持 **单线程进程**。  
- **现代 OS 支持多线程**，即 **一个进程可以包含多个线程**，它们共享 **相同的地址空间**。

---

### **示例：进程创建与内存分配**
以 **计算素数的 C 程序** 为例：  
```c
const int nprimes = 100;
int prime[nprimes];
int main() {
   int i;
   int current = 2;
   prime[0] = current;
   for (i=1; i<nprimes; i++) {
      int j;
   NewCandidate:
      current++;
      for (j=0; prime[j]*prime[j] <= current; j++) {
       if (current % prime[j] == 0)
        goto NewCandidate;
      }
      prime[i] = current;
   }
   return(0);
}
```
1. **OS 先编译并链接代码**，存储为 **可执行文件**。  
2. **当程序执行时**，OS **创建进程** 并将程序加载到 **进程地址空间**。  
3. **不同类型的变量存储在不同的内存区域**：
   - **全局变量 (`nprimes, prime[]`)** → **数据段（Data）**。  
   - **局部变量 (`i, j, current`)** → **栈区（Stack）**。  
   - **动态内存 (`malloc()`)** → **堆区（Heap）**。  

**示例：动态分配存储素数数组**
```c
int nprimes;
int *prime;
int main(int argc, char *argv[]) {
   int i;
   int current = 2;
   nprimes = atoi(argv[1]);
   prime = (int *)malloc(nprimes*sizeof(int));
   prime[0] = current;
   for (i=1; i<nprimes; i++) {
      int j;
NewCandidate:
      current++;
      for (j=0; prime[j]*prime[j] <= current; j++) {
       if (current % prime[j] == 0)
        goto NewCandidate;
     }
     prime[i] = current;
   }
   return(0);
}
```

```c
int *prime;
prime = (int *)malloc(nprimes * sizeof(int));  // 在堆区动态分配内存
```
- **堆内存会根据需要扩展**，使用 **系统调用 `sbrk()`**。

---

### **操作系统如何管理内存？**  
✅ **全局变量在整个进程生命周期内都可用**（数据段）。  
✅ **局部变量只在函数执行期间存在**（栈区）。  
✅ **动态内存（堆区）需要程序手动分配和释放**。  
✅ **通过内存布局，操作系统提高了程序执行效率，并保证进程隔离**。

---

## **进程管理**  

### **创建进程：`fork()` 系统调用**  
在 Unix 中，**唯一的进程创建方法** 是使用 `fork()`。  
- `fork()` **创建一个新进程**，它是 **当前进程的副本**。  
- 新进程（子进程）和原进程（父进程）**最初共享相同的代码**。  

#### **`fork()` 的工作原理**
- 子进程的地址空间包含：  
  - 父进程的 **代码段、BSS 段、数据段、堆和栈的副本**。  
  - **代码段是共享的**（因为代码是只读的，无需复制）。  
- `fork()` **返回两次**：  
  - **子进程返回 `0`**。  
  - **父进程返回子进程的进程 ID (PID)**。  

#### **示例：`fork()`**
```c
if (fork() == 0) {
   /* 这是子进程执行的代码 */
} else {
   /* 这是父进程执行的代码 */
}
```
- 这样，父进程和子进程 **可以执行不同的逻辑**。

---

### **进程控制块（PCB）**  
每个进程都有一个 **进程控制块（PCB）**，它是 **操作系统管理进程的核心数据结构**。  
- **包含的信息：**  
  - **进程 ID (PID)**  
  - **父进程的 PID**  
  - **进程状态**（运行、睡眠、僵尸等）  
  - **进程退出码**  

📌 **进程控制块示意图**  
```
+------------+      +------------+      +------------+
|  父进程    | ---> |  子进程 1   | ---> |  子进程 2   |
|            |      |  (僵尸态)  |      |  (僵尸态)  |
+------------+      +------------+      +------------+
```

---

### **进程终止：`exit()` 系统调用**  
进程调用 `exit()` 终止自身，并传递 **退出码**：
```c
exit(n);
```
- `n = 0` 表示 **成功执行**。  
- `n > 0` 表示 **发生错误**。  
- 如果程序 **从 `main()` 返回**，会自动调用 `exit()`。  

---

### **等待进程：`wait()` 系统调用**  
父进程可以使用 `wait()` **等待子进程终止**：
```c
short pid;
if ((pid = fork()) == 0) {
   /* 子进程执行一些代码 */
   exit(n);
} else {
   int ReturnCode;
   while (pid != wait(&ReturnCode));
   /* 父进程获取子进程的退出码 */
}
```
🔹 **关键点：**  
✅ `wait()` 确保 **父进程获取子进程的返回值**。  
✅ `wait()` 返回 **终止的子进程的 PID**。  
✅ 进程 **只能等待它的子进程**，不能等待其他进程。

---

### **僵尸进程（Zombie Process）与 PID 复用**  
- 当进程调用 `exit()`，它 **不会立即被删除**。  
- 它进入 **僵尸状态（Zombie State）**，其中：
  - **释放地址空间**，但  
  - **PID 和退出码仍然保留**。  
- **父进程必须调用 `wait()` 以清除僵尸进程**，否则会占用系统资源。

**如果父进程提前终止？**  
- 孤儿进程将 **由进程 1 (`init`) 继承**，它会循环调用 `wait()` 以清理僵尸进程。

---

### **总结**
✅ `fork()` 创建一个新进程，从相同的代码开始执行。  
✅ `fork()` 在子进程中返回 `0`，在父进程中返回 **子进程的 PID**。  
✅ `exit()` 终止进程，并返回退出码。  
✅ `wait()` 确保父进程 **获取子进程的返回值**。  
✅ **僵尸进程会保留 PID，直到 `wait()` 释放它**。

---

## **将程序加载到进程 (`exec()`)**  

### **替换进程的地址空间**  
我们之前讨论了 **操作系统如何初始化进程的地址空间**，现在来看 **进程如何加载新的程序**。  

🔹 **`exec` 系统调用会替换当前进程的整个内存**。  
🔹 **常见应用场景**：  
   - **父进程创建子进程（`fork()`）**。  
   - **子进程用 `exec()` 替换自己的内存**，加载新程序。  
   - **父进程等待子进程完成执行**。

---

### **`exec()` 的工作原理**  
`exec()` **完全替换进程的内存**：  
✅ **代码段（Text）** → 用新程序的可执行代码替换。  
✅ **数据段 & BSS（Data & BSS）** → 用新程序的变量替换。  
✅ **堆（Heap）** → 清空。  
✅ **栈（Stack）** → 存储新程序的 **命令行参数**。  
✅ **程序从 `main()` 开始执行**。  

📌 **关键点**：  
- **如果 `exec()` 成功，它不会返回**，因为旧的进程已经 **完全被新程序替换**。  
- **如果 `exec()` 失败**，则返回错误代码。

---

### **示例：使用 `execl()`**
```c
int pid;
if ((pid = fork()) == 0) {
     /* 子进程替换自身，加载新程序 */
     execl("/home/twd/bin/primes", "primes", "300", 0);
     exit(1);  // exec 失败时，退出并返回错误
}

/* 父进程继续执行 */
while(pid != wait(0)) /* 忽略返回码 */
   ;
```

#### **执行过程**
1. **父进程调用 `fork()`**，创建子进程。  
2. **子进程调用 `exec()`**，用 `primes` 程序替换自身。  
3. **父进程调用 `wait()`**，等待子进程结束。  

📌 **在 Shell 中的等效命令**：
```
% primes 300
```
这与 **Shell 运行命令的方式相同**：  
- Shell **创建进程（`fork()`）**，  
- **加载命令（`exec()`）**，  
- **等待进程结束（`wait()`）**。  

---

### **总结**
✅ **`exec()` 用新程序替换当前进程的内存**。  
✅ **如果 `exec()` 成功，它不会返回（因为旧程序已被替换）**。  
✅ **如果 `exec()` 失败，进程需要处理错误（例如 `exit(1)`)**。  
✅ **Shell 运行命令时，使用 `fork()` + `exec()` 执行**。

---

## **Unix 文件**  

### **为什么需要文件？**  
在之前的例子中，我们的 **primes 程序运行在内存中**，意味着 **进程终止后，计算结果就丢失了**。  

🔹 **文件解决了这个问题**，它提供了 **持久存储（Persistent Storage）**，让数据：  
1. **在进程退出后仍然存在**。  
2. **可以被其他程序或用户访问**。  

---

### **Unix 文件：统一抽象**
Unix **将一切视为文件**，包括：  
- **普通文件**（文本文件、二进制文件、日志）。  
- **设备**（键盘、显示器、磁盘）。  
- **进程间通信（IPC）**（管道、套接字）。  

📌 **核心思想**：
- 文件让程序能够 **存储、检索、共享数据**。  
- 进程可以 **读/写文件**，就像它可以 **和其他进程或硬件交互**。  

---

### **Unix 如何使用文件？**
Unix 文件有两个主要用途：  
1. **持久存储** – 例如存储文本、日志、数据库。  
2. **连接外部数据源** – 进程可以通过文件 **与设备或其他进程通信**。  

**示例**：
- **程序写入文件** → **另一个程序可以读取数据**。  
- **进程从键盘读取输入** → **另一个进程向显示器输出数据**。  

---

### **总结**
✅ **文件让数据在进程终止后仍然可用**。  
✅ **Unix 统一抽象：所有东西都是文件（包括设备、进程间通信）**。  
✅ **程序通过文件高效地读、写、共享数据**。

---

## **文件命名**  

### **如何引用文件？**  
**文件存储在进程地址空间之外**，因此我们需要 **文件命名系统** 来访问它们。  
- **大多数操作系统使用层级（树状）目录结构**。  
- **文件路径表示从根目录到文件的层级关系**。  

📌 **不同系统的路径命名**  
| **操作系统** | **路径分隔符** | **示例** |
|--------------|--------------|--------------|
| **Unix/Linux** | `/`（正斜杠） | `/home/user/file.txt` |
| **Windows** | `\`（反斜杠） | `C:\Users\User\file.txt` |

---

### **操作系统如何访问文件？**
1. **进程通过路径请求文件**（如 `/home/twd/file`）。  
2. **OS 检查文件是否存在，并验证访问权限**。  
3. **如果权限允许，OS 返回文件句柄（在 Unix 中称为文件描述符）**。  
4. **后续的读/写操作使用文件描述符，而不是路径**。  

📌 **为什么使用文件句柄？**  
- **提高效率**：每次访问文件时重新遍历目录树 **会非常慢**。  
- **增强安全性**：OS 通过文件句柄 **控制权限**。  
- **简化操作**：文件打开后，**可以多次读/写，而不需要每次都查找路径**。  

---

### **示例：在 Unix 中打开 & 读取文件**
```c
int fd;
char buffer[1024];
int count;

if ((fd = open("/home/twd/file", O_RDWR)) == -1) {
   /* 文件打开失败 */
   perror("/home/twd/file");
   exit(1);
}

if ((count = read(fd, buffer, 1024)) == -1) {
   /* 读取失败 */
   perror("read");
   exit(1);
}
/* buffer 现在包含从文件中读取的 count 个字节 */
```
📌 **解析**  
- `open()` **尝试以读/写权限 (`O_RDWR`) 打开文件 `/home/twd/file`**。  
- 如果 `open()` 失败，**返回 `-1`，并打印错误信息**。  
- `read()` **读取文件的前 1024 字节**，存入 `buffer`。  
- 如果 `read()` 失败，**打印错误信息**。

---

### **总结**
✅ **Unix 使用层级目录结构，文件通过路径命名**。  
✅ **文件打开后，系统返回文件句柄（文件描述符）**，用于后续操作。  
✅ **使用文件描述符进行读/写，提高效率，避免重复路径解析**。

---

## **Unix 文件描述符**  

### **什么是文件描述符？**  
**文件描述符（File Descriptor）** 是 **操作系统在进程打开文件时分配的小整数**。  
- **它扩展了进程的地址空间**，允许进程访问外部数据。  
- **文件描述符在 `exec()` 之后仍然有效**，意味着进程可以在执行新程序前 **修改文件描述符的关联**。  

📌 **Unix 标准文件描述符**  
| **文件描述符** | **作用** | **默认输入/输出** |
|--------------|------------|------------------|
| `0` | **标准输入** | 键盘 (`stdin`) |
| `1` | **标准输出** | 终端 (`stdout`) |
| `2` | **标准错误** | 终端 (`stderr`) |

🔹 **进程可以更改这些关联，将输出/错误信息写入文件**。

---

### **示例：在 `exec()` 前重定向输出**
```c
if (fork() == 0) { // 子进程
   close(1); // 关闭标准输出
   if (open("/home/twd/Output", O_WRONLY) == -1) {
      perror("/home/twd/Output");
      exit(1);
   }
   execl("/home/twd/bin/primes", "primes", "300", 0);
   exit(1);
}

/* 父进程继续执行 */
while (pid != wait(0));
```
📌 **解析：**  
1. **子进程关闭文件描述符 `1`（标准输出）**。  
2. **打开文件 `/home/twd/Output`，并将其赋值为 `1`**（因为文件描述符是 **从最小值开始分配的**）。  
3. **`exec()` 之后，`primes` 进程的 `printf()` 输出写入 `/home/twd/Output`**。  

---

### **写入二进制数据**
```c
if (write(1, prime, nprimes * sizeof(int)) == -1) {
   perror("primes output");
   exit(1);
}
```
📌 **问题**：如果 `stdout` 没有重定向，**终端会显示乱码**（因为数据是二进制格式）。  

---

### **写入可读的文本格式**
```c
for (i = 0; i < nprimes; i++) {
   printf("%d\n", prime[i]);
}
```
📌 **Shell 命令：**
```
% primes 300 > /home/twd/Output
```
✅ **将 `stdout` 重定向到 `/home/twd/Output`**，以可读文本格式存储。  

---

### **文件描述符的共享 & `dup()`**
📌 **让 `stdout` 和 `stderr` 指向同一文件**
```c
close(1);
close(2);
if (open("/home/twd/Output", O_WRONLY) == -1) {
   exit(1);
}
dup(1); // 复制文件描述符 1（标准输出）到 2（标准错误）
```
📌 **Shell 语法：**
```
% program >& /home/twd/Output
```

---

### **总结**
✅ **文件描述符扩展了进程的地址空间**。  
✅ **`exec()` 不影响打开的文件描述符**。  
✅ **使用 `dup()` 共享相同的文件写入位置**。  
✅ **子进程和父进程共享相同的文件写入位置，防止数据覆盖**。

---

## **文件的随机访问**  

### **顺序访问 vs. 随机访问**  
- 在 Unix 中，**默认情况下，文件的读写是顺序进行的**。  
- **连续的 `read()` 和 `write()` 操作会自动推进文件指针**。  
- **随机访问允许程序在文件的任意位置进行读写**。  

📌 **关键机制**：
- **每个打开的文件都有一个 "文件位置" 指针**，记录当前的 **读/写位置**。  
- **`lseek()` 允许手动调整文件位置，实现随机访问**。

---

### **使用 `lseek()` 进行随机访问**
```c
fd = open("textfile", O_RDONLY);
/* 跳转到文件的最后一个字符 */
fptr = lseek(fd, (off_t)-1, SEEK_END);
while (fptr != -1) {
   read(fd, buf, 1);
   write(1, buf, 1);
   fptr = lseek(fd, (off_t)-2, SEEK_CUR);
}
```
📌 **解析**：  
1. **`open("textfile", O_RDONLY)`** → 以只读模式打开文件。  
2. **`lseek(fd, -1, SEEK_END)`** → 将文件指针移动到 **最后一个字符**。  
3. **读取 1 个字节并输出**。  
4. **使用 `lseek(fd, -2, SEEK_CUR)` 将指针向后移动 2 个字节**。  
5. **循环读取，直到到达文件开头**。  

---

### **`lseek()` 详解**
```c
off_t lseek(int fd, off_t offset, int whence);
```
| **参数** | **说明** |
|----------|----------|
| `fd` | 文件描述符 |
| `offset` | 偏移量（可正可负） |
| `whence` | 参考点（`SEEK_SET`, `SEEK_CUR`, `SEEK_END`） |

📌 **`whence` 选项**  
| **模式** | **意义** |
|---------|------------|
| `SEEK_SET` | 从 **文件开始** 计算偏移量 |
| `SEEK_CUR` | 从 **当前文件位置** 计算偏移量 |
| `SEEK_END` | 从 **文件末尾** 计算偏移量 |

✅ **`lseek()` 仅修改文件指针，不进行实际 I/O 操作**。

---

### **总结**
✅ **默认情况下，文件访问是顺序进行的**。  
✅ **`lseek()` 允许程序定位到文件的任意位置**。  
✅ **适用于倒序读取、修改特定部分等应用场景**。

---

## **Unix 中的管道（Pipe）**  

### **什么是管道？**  
- **管道（Pipe）允许两个进程进行通信**，就像 **一个进程写入文件，另一个进程读取文件** 一样。  
- **发送方写入管道**，接收方 **从管道读取** 数据。  

📌 **管道的特点**：
✅ **单向通信** → 一个进程写入，另一个进程读取。  
✅ **仅存在于内存中** → **不会存储为文件**。  
✅ **只能在相关进程间共享** → **管道必须在 `fork()` 之前创建**，子进程才能继承它。  

---

### **创建管道：`pipe()` 系统调用**
```c
int p[2];   /* 用于存储管道的文件描述符 */
pipe(p);    /* 创建管道 */
```
📌 **工作原理**：
- **`p[0]` → 读取端**（`read()`）。  
- **`p[1]` → 写入端**（`write()`）。  

调用 `pipe(p)` 后，内核创建一个 **管道对象**，并返回两个文件描述符：
| **文件描述符** | **用途** |
|--------------|---------|
| `p[0]` | 读取管道 |
| `p[1]` | 写入管道 |

---

### **示例：父进程向子进程发送数据**
```c
int p[2];    /* 管道文件描述符 */
pipe(p);     /* 创建管道 */
if (fork() == 0) {   // 子进程
   char buf[80];
   close(p[1]);  /* 关闭写入端（子进程不需要写入） */
   while (read(p[0], buf, 80) > 0) {
      /* 处理来自父进程的数据 */
      ...
   }
} else {  // 父进程
   char buf[80];
   close(p[0]);  /* 关闭读取端（父进程不需要读取） */
   for (;;) {
      /* 准备数据发送给子进程 */
      ...
      write(p[1], buf, 80);
   }
}
```
📌 **解析**：
1. **父进程在 `fork()` 之前创建管道**，子进程继承它。  
2. **子进程关闭 `p[1]`（写入端）**，只从 `p[0]` 读取数据。  
3. **父进程关闭 `p[0]`（读取端）**，只向 `p[1]` 写入数据。  
4. **父进程不断写入数据，子进程不断读取数据**。  

✅ **实现了父子进程之间的通信！**

---

### **Shell 中的管道（`|`）**
在 shell 中，管道 (`|`) 也是一样的：
```
ls | grep "txt"
```
📌 **内部工作原理**：
- **Shell 创建管道**。  
- `ls` **写入管道 (`p[1]`)**。  
- `grep "txt"` **从管道 (`p[0]`) 读取数据**。  

---

### **总结**
✅ **管道用于进程间通信（IPC）**。  
✅ **必须在 `fork()` 之前创建，以便子进程继承它**。  
✅ **只有继承文件描述符的进程才能访问管道**。  
✅ **管道是单向的，一个进程写入，另一个进程读取**。

---

## **Unix 目录**  

### **什么是目录？**  
目录是一种**特殊的文件**，用于存储**文件的引用（名称 + inode 号）**。  
- **inode 是文件系统中的数据结构，唯一标识文件**。  
- **目录存储文件名和对应的 inode 号**，使文件可被访问。  

📌 **目录的特点**  
✅ **包含文件引用（文件名 + inode 号）**。  
✅ **支持分层文件组织**（目录结构）。  
✅ **包括两个特殊条目：`.`（当前目录），`..`（上级目录）**。  

---

### **理解 inode & 硬链接**
- **inode 代表文件本身，而目录只是存储文件名和 inode 号**。  
- **硬链接（Hard Link）使多个目录条目指向同一 inode**。  
- **只有当 inode 计数归零时，文件才会真正删除**。  

📌 **示例：硬链接的行为**
```
$ ln /unix /etc/image
```
现在 `/unix` 和 `/etc/image` **指向同一个文件**（相同的 inode）。  
- **删除 `/unix` (`rm /unix`)，文件仍然存在**，因为 `/etc/image` 仍然指向它。  
- **只有所有硬链接都删除，文件才会真正消失**。  

✅ **内核跟踪指向文件的链接数（link count）。**  
✅ **文件只有在 link count 和引用计数（打开的文件数）都归零时才会删除。**  

---

### **符号（软）链接**
**符号链接（Symbolic Link）是一种特殊的文件，存储的是另一个文件的路径**。  
- **不同于硬链接，符号链接是一个独立的文件**。  
- **系统访问符号链接时，会解析路径并找到目标文件**。  

📌 **示例：创建符号链接**
```
$ ln -s /unix /home/twd/mylink
```
现在，`/home/twd/mylink` **指向** `/unix`。  
- **如果 `/unix` 被删除，`/home/twd/mylink` 变成“悬挂链接”（Broken Link）**。  

✅ **符号链接可以跨文件系统链接**。  
✅ **可以指向目录，而硬链接不能**。  

---

### **工作目录 & 路径解析**
- 每个**进程都有一个工作目录**（所有相对路径都从这里开始）。  
- **改变工作目录**：
  ```
  $ cd /home/user
  ```
  - 现在 `file.txt` 可以用 `./file.txt` 访问（相当于 `/home/user/file.txt`）。  

📌 **获取当前工作目录**
```
$ pwd
```
- `pwd` **返回当前工作目录的绝对路径**。  

---

### **总结**
✅ **目录存储文件引用（名称 + inode 号）。**  
✅ **硬链接指向相同 inode，文件不会因一个链接删除而消失。**  
✅ **符号链接存储路径，可以跨文件系统。**  
✅ **进程的工作目录影响相对路径的解析。**

---

## **Unix 访问权限**  

### **为什么需要访问控制？**
操作系统必须 **防止未经授权的访问** 以保护数据安全。  
- **每个文件都有访问权限，决定谁可以读取、修改或执行它**。  
- **权限与安全主体（security principals）相关**：
  1. **用户（文件所有者）**。  
  2. **用户组（与所有者同组的用户）**。  
  3. **其他用户（系统中的其他所有用户）**。  

---

### **文件权限详解**
每个文件包含 **三组权限**：  
1. **用户权限（User）** → 适用于文件所有者。  
2. **组权限（Group）** → 适用于与所有者同组的用户。  
3. **其他权限（Others）** → 适用于所有其他用户。  

📌 **权限类型**  
| **符号** | **文件权限** | **目录权限** |
|--------|------------|------------|
| `r` (读取) | 可以读取文件内容 | 可以列出目录内容 |
| `w` (写入) | 可以修改文件 | 可以创建/删除文件 |
| `x` (执行) | 可以运行文件 | 可以进入该目录 |

📌 **示例：列出文件权限**
```
$ ls -lR
.:
total 2
drwxr-x--x  2 tom    adm     1024 Dec 17 13:34 A
drwxr-----  2 tom    adm     1024 Dec 17 13:34 B
```
📌 **如何读取权限信息？**  
```
drwxr-x--x  2 tom  adm   1024 Dec 17 13:34 A
```
- `d` → **目录**。  
- `rwx` → **所有者 (`tom`) 可读、写、执行**。  
- `r-x` → **组 (`adm`) 可读、执行**。  
- `--x` → **其他人只能执行（可进入目录，但不能列出内容）**。  

---

### **访问权限示例**
#### **场景：Andy 能列出目录 A 吗？**
❌ **不能**
- Andy 属于 "others"（`--x`）。  
- 他可以 **进入目录**（`x`），但 **不能列出内容**（缺少 `r`）。  

#### **场景：Andy 能读取 `A/x` 吗？**
✅ **可以**
- Andy **可以进入 A**（`x` 权限）。  
- `A/x` **是世界可读（`rw-rw-rw-`）的**。  

#### **场景：Trina 能列出目录 B 吗？**
✅ **可以**
- Trina 是 `adm` 组成员，目录 `B` **组权限为 `r-----`（可读）**。  

#### **场景：Trina 能修改 `B/y` 吗？**
❌ **不能**
- **B 没有 `x` 权限**，所以 Trina **无法进入 B**，也就 **无法访问 `y`**。  

#### **场景：Tom 能修改 `B/x` 吗？**
❌ **不能**
- **Tom 是 `B/x` 的所有者**，但 **只有 `r--` 权限**。  

#### **场景：Tom 能读取 `B/y` 吗？**
❌ **不能**
- **Tom 属于 `adm` 组**，但 `B/y` **对组无权限 (`------`)**。  

---

### **修改文件权限**
📌 **使用 `chmod` 修改权限**
```
$ chmod 755 filename
```
- `755` 代表 **rwxr-xr-x**：  
  - **所有者：读、写、执行**。  
  - **组：读、执行**。  
  - **其他用户：读、执行**。  

📌 **使用 `chown` 更改文件所有者**
```
$ chown tom:adm filename
```

📌 **设置默认权限 (`umask`)**
```
$ umask 022
```
- 新文件默认权限：**`rw-r--r--`**（只有所有者可以写）。  

---

### **总结**
✅ **文件权限决定谁可以读取、写入或执行文件**。  
✅ **目录需要 `x` 权限才能进入**。  
✅ **使用 `chmod`、`chown`、`umask` 管理权限**。

---

## **Unix 文件创建**  

### **如何创建文件？**  
Unix 提供 **两种方式** 创建文件：  
1. **`creat()` 系统调用**（旧方法）。  
2. **`open()` 系统调用，使用 `O_CREAT` 标志**（现代方法）。  

---

### **使用 `creat()` 创建文件**  
```c
int fd = creat("newfile.txt", 0666);
```
📌 **解析**：  
- 创建文件 `newfile.txt`（**如果文件不存在**）。  
- `0666` → 设置文件权限（**所有用户可读写**）。  
- **如果文件已经存在，`creat()` 会清空文件内容！**  

❗ **`creat()` 的缺点**：  
- 不能创建 **"如果文件存在则不覆盖"** 的文件。  
- 在现代 Unix 系统中，更推荐使用 `open()`。  

---

### **使用 `open()` 创建文件**
```c
int fd = open("newfile.txt", O_CREAT | O_EXCL, 0666);
```
📌 **解析**：  
- **`O_CREAT`** → 如果文件 **不存在**，则创建它。  
- **`O_EXCL`** → 确保 **如果文件已存在，返回错误（不覆盖）**。  
- **如果不加 `O_EXCL`，文件存在时 `open()` 只会打开它，而不会报错**。  

📌 **清空文件内容（`O_TRUNC`）**
```c
int fd = open("existingfile.txt", O_CREAT | O_TRUNC, 0666);
```
- **如果文件存在，`O_TRUNC` 会清空文件内容**。  

---

### **理解 `umask`：控制文件默认权限**
当创建文件时，**实际权限取决于**：
1. **`open()` 或 `creat()` 指定的 mode 参数（如 `0666`）**。  
2. **进程的 `umask`（操作系统用于屏蔽部分权限的设置）**。  

📌 **`umask` 的工作方式**
```c
最终权限 = mode & ~umask;
```
✅ **示例**：  
- 创建文件，指定权限 `0666`（所有用户可读写）。  
- 进程的 **`umask` 是 `0022`（去掉组和其他用户的写权限）**。  
- **最终文件权限**: `0666 & ~0022 = 0644`（所有者可读写，其他人只读）。  

📌 **在 Shell 里设置 `umask`**
```sh
$ umask 0027
```
- 这样新文件 **默认不给其他人访问权限**。  

📌 **在 C 代码中设置 `umask`**
```c
umask(0027);
```

---

### **总结**
✅ **`creat()` 创建文件，但会清空已有文件内容**。  
✅ **`open()` + `O_CREAT` 是推荐的创建方式**。  
✅ **`O_EXCL` 可防止覆盖已有文件**。  
✅ **`umask` 控制新文件的默认权限**。